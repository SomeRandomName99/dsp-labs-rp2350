I thought that creating a passthrough ought to be a simple task. Little did I know that there was so much involved. I first had to learn the basics of the USB Protocol in order to understand all the required descriptors that I have to create with Tiny USB.

I then learned about PIO and how to get audio data from the IC43434's weird protocol, where data first gets transmitted after the second clock cycle of the channel's time slot. I am glad that I did not have to bit bang this weird I2S implementation on the processing core. Chaining PIO interrupts and DMAs was also interesting, this allowed me to get the maximum possible throughput and free the processing core to do the actual processing.

After the computer recognized my microcontroller as a mic and data streaming started working, I started working on signal conditioning, first I learned about dithering and how it decorrelates the noise from the input signal, this removes the hissing sound that is sometimes audible by removing the noise harmonics from the signal. Turns out that there are multiple types of dithering, triangular dithering is supposed to be better than uniform, because it ensures that the expected value of the quantization error is strictly independent of the input signal, this is because the mean and variance of the quantization noise are zero when using a triangular distribution, as opposed to only a mean of zero with the uniform one. I could go endlessly deep into this topic, but mathematical details of DSP are not the goal of this post. Maybe I will get around to explaining this stuff later in more detail.

In order to create a triangular distribution, I had to create a uniform one which requires an implementation of a random number generator(RNG). I thought about using C++'s standard implementations, but they are slow, clunky and even fail basic statistical tests. After searching a bit I learned about the XORSHIFT algorithm, it consists of 3 bit shifts! I do not think that it can be beaten in terms of performance. It might be predictable, but we do not really care when only using it for dithering.

An implementation of dithering is not complete without using the lrintf(round to the nearest integer) function. There's nothing special about this function and it can be directly imported from `math.h`, however the ARM Cortex M33 includes a hardware function that does that. So I wrote some inline assembly in order to perform rounding in an instruction.

Finally, I learned how to use CMSIS-DSP, which is a collection of functions distributed by ARM that utilize DSP hardware (if available, M33 includes it) on ARM chips to perform DSP-related functions. I used a very crude FIR filter to implement a DC-blocker, it doesn't have the narrowest stop band, so a lot of low frequencies get attenuated. I will redesign this filter in lab 3. It was pretty cool to see the disassembly of the filter functions which were a series of FMA instructions. I then used ARM's vector scaling function to amplify the sound a bit. The whole thing takes 44ns per data packet! There is still a lot of room for cool stuff left :D.